<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // Promise
        // Promise是JS解决异步编程的方法之一，其英文意思是承诺。
        //     在程序中可理解为等一段时间就会执行，等一段时间就是JS中的异步。
        //     异步是指需要比较长的时间才能执行完成的任务，例如网络请求，读取文件等。
        //     Promise是一个实例对象，可从中获取异步处理的结果。

        // Promise有3种状态，
        //     分别是pending(进行中)、fulfilled(已成功)、rejected(已失败)。
        //     只有异步操作可改变Promise的状态，其他操作都无法改变。
        //     并且状态改变后就不会再变，
        //     只能是从pending到fulfiled或pending到rejected，这也是Promise一个比较鲜明的特点。



        // resolve将状态从pending变为fulfiled，成功时调用。
        // reject将状态从pending变为rejected，失败时调用
        // Promise {<pending>} ==> fulfiled | rejected
        function RunPromise(num, time) {
            return new Promise((resolve, reject) => {
                console.log("开始执行");
                if(num % 2 === 0){
                    setTimeout(function(){
                        resolve(`偶数时调用resolve, 此时num为${num}`);
                    },time)
                }
                else{
                    setTimeout(function(){
                        reject(new Error(`奇数数时调用reject, 此时num为${num}`));  
                    },time)
                }
            })  
        }
        // console.log(RunPromise(1, 1000).then(v => console.log(v)).catch(e => console.log(e)))
        RunPromise(22, 20000).then(res => {
            // console.log("then的第一个参数执行");
            // console.log(res);
            // console.log(newres);
        }, error => {
            // console.log("then的第二个参数执行");
            // console.log(error);
        }).catch(error => {
            // console.log("error");
            // console.log(error);
        });
        // 上面例子中，RunPromise()调用resolve，then()的第一个参数对应回调，状态从pending改成fulfilled，且状态不会再改变。
        // 在then()中，newres这个变量尚未定义，因此程序出错，其异常在catch()被捕获。
        // 一般来说，then()使用第一个参数即可，因为catch()跟then()的第二个参数一样，还能捕获到异常




        




    </script>
</body>
</html>